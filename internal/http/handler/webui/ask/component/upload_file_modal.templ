package component

import (
	"github.com/bornholm/corpus/internal/core/model"
	common "github.com/bornholm/corpus/internal/http/handler/webui/common/component"
	"strings"
)

type UploadFileModalVModel struct {
	SupportedExtensions []string
	WritableCollections []model.PersistedCollection
	CreateCollectionURL string
}

templ UploadFileModal(vmodel UploadFileModalVModel) {
	{{ hasWritableCollection := len(vmodel.WritableCollections) > 0 }}
	<div class="modal is-active">
		<div class="modal-background"></div>
		<form
			method="post"
			enctype="multipart/form-data"
			action={ common.BaseURL(ctx, common.WithPath("/index")) }
			hx-on:submit="htmx.addClass(htmx.find('#index-submit'), 'is-loading')"
		>
			<div class="modal-card">
				<header class="modal-card-head">
					<p class="modal-card-title">Ajouter un fichier</p>
				</header>
				<section class="modal-card-body">
					if hasWritableCollection {
						<div class="field">
							<div class="control">
								<div class="file has-name is-fullwidth">
									<label class="file-label">
										<input
											class="file-input"
											type="file"
											name="file"
											required
											hx-on:change="onFileChange.call(this)"
											accept={ strings.Join(vmodel.SupportedExtensions, ", ") }
										/>
										<span class="file-cta">
											<span class="file-icon">
												<i class="fas fa-upload"></i>
											</span>
											<span class="file-label">Choisissez un fichier</span>
										</span>
										<span class="file-name"></span>
									</label>
								</div>
							</div>
							<p class="help">Formats acceptés: <code>{ strings.Join(vmodel.SupportedExtensions, ", ") }</code></p>
						</div>
						<div class="field">
							<label class="label">URL</label>
							<div class="control">
								<input class="input" type="url" required name="source" placeholder="https://myserver/mydocument.md"/>
							</div>
							<p class="help">L'URL unique qui sera associée au document.</p>
						</div>
					}
					<div class="field">
						<label class="label">Collection(s)</label>
						if !hasWritableCollection {
							<div class="message is-warning">
								<div class="message-body">
									Vous n'avez aucune collection accessible en écriture.
									<a href={ templ.SafeURL(vmodel.CreateCollectionURL) } class="has-text-weight-bold">Créez votre première collection</a> pour pouvoir indexer des documents.
								</div>
							</div>
						} else {
							<div class="control">
								for i, collection := range vmodel.WritableCollections {
									<label class="checkbox is-block">
										<input
											type="checkbox"
											name="collection"
											value={ string(collection.ID()) }
											if i == 0 {
												checked
												required
											}
											onchange="validateCollectionSelection()"
										/>
										{ collection.Label() }
										if collection.Description() != "" {
											<span class="has-text-grey">- { collection.Description() }</span>
										}
									</label>
								}
							</div>
							<p class="help">Sélectionnez une ou plusieurs collections pour associer le document. Au moins une collection doit être sélectionnée.</p>
						}
					</div>
				</section>
				<footer class="modal-card-foot">
					<div class="buttons is-right" style="width:100%">
						<a href={ common.CurrentURL(ctx, common.WithoutValues("action", "*")) } class="button is-medium">Annuler</a>
						if hasWritableCollection {
							<button type="submit" id="index-submit" class="button is-success is-medium">Indexer</button>
						}
					</div>
				</footer>
			</div>
		</form>
	</div>
	<script>
	   function onFileChange() {
	     if (this.files.length > 0) {
	       const fileNameInput = this.parentNode.querySelector(".file-name");
	       const name = this.files[0].name;
	       fileNameInput.textContent = name;
	       
	       const sourceInput = this.closest("form").querySelector(`input[name="source"]`)
	       if (!sourceInput.value) {
	         sourceInput.value = `file://${name.replace(/\s+/g, '-')}`
	       }
	     }
	   }

	   function validateCollectionSelection() {
	     const checkboxes = document.querySelectorAll('input[name="collection"]');
	     const checkedBoxes = document.querySelectorAll('input[name="collection"]:checked');
	     const submitButton = document.getElementById('index-submit');
	     
	     if (checkedBoxes.length === 0) {
	       // If no collections are checked, make the first one required
	       if (checkboxes.length > 0) {
	         checkboxes[0].required = true;
	       }
	       submitButton.disabled = true;
	     } else {
	       // If at least one is checked, remove required from all
	       checkboxes.forEach(cb => cb.required = false);
	       submitButton.disabled = false;
	     }
	   }

	   // Initialize validation on page load
	   document.addEventListener('DOMContentLoaded', function() {
	     validateCollectionSelection();
	   });
	 </script>
}
